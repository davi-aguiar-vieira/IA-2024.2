{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portf\u00f3lio 2 - Intelig\u00eancia Artificial","text":""},{"location":"#agente-de-solucoes-de-problemas","title":"Agente de Solu\u00e7\u00f5es de Problemas","text":"<p>Um agente de solu\u00e7\u00e3o de problemas \u00e9 uma entidade aut\u00f4noma projetada para atuar em um ambiente com o objetivo de atingir metas definidas. Ele segue um processo sistem\u00e1tico para identificar, analisar e resolver problemas. Esses agentes s\u00e3o fundamentais na Intelig\u00eancia Artificial (IA), sendo aplicados em \u00e1reas como tomada de decis\u00e3o, planejamento e automa\u00e7\u00e3o.</p>"},{"location":"#1-formulacao-de-objetivos","title":"1. Formula\u00e7\u00e3o de Objetivos","text":"<p>A formula\u00e7\u00e3o de objetivos \u00e9 a etapa inicial onde as metas s\u00e3o claramente definidas. Objetivos bem delineados orientam todas as fases seguintes, garantindo que os esfor\u00e7os do agente sejam direcionados eficientemente. Segundo Russell e Norvig (2010), a qualidade dessa formula\u00e7\u00e3o afeta diretamente a efici\u00eancia do processo de solu\u00e7\u00e3o de problemas.</p>"},{"location":"#2-formulacao-do-problema","title":"2. Formula\u00e7\u00e3o do Problema","text":"<p>Na formula\u00e7\u00e3o do problema, o agente descreve os elementos necess\u00e1rios para resolv\u00ea-lo, incluindo:</p> <ul> <li>Estado inicial: Situa\u00e7\u00e3o atual do sistema.</li> <li>Estados objetivos: Condi\u00e7\u00f5es que representam o sucesso.</li> <li>A\u00e7\u00f5es poss\u00edveis: Conjunto de opera\u00e7\u00f5es ou movimentos que o agente pode executar.</li> <li>Fun\u00e7\u00e3o de custo: Avalia o esfor\u00e7o ou custo associado a cada a\u00e7\u00e3o.</li> </ul> <p>Por exemplo, em um jogo de xadrez, o estado inicial \u00e9 a disposi\u00e7\u00e3o das pe\u00e7as no tabuleiro, os estados objetivos incluem situa\u00e7\u00f5es como xeque-mate, e as a\u00e7\u00f5es poss\u00edveis correspondem aos movimentos permitidos para cada pe\u00e7a.</p>"},{"location":"#3-busca","title":"3. Busca","text":"<p>A busca \u00e9 a etapa onde o agente explora o espa\u00e7o de solu\u00e7\u00f5es em busca do caminho mais eficiente para atingir o objetivo. Isso \u00e9 feito de forma simulada, antes da execu\u00e7\u00e3o real das a\u00e7\u00f5es.</p> <p>Classifica\u00e7\u00e3o de algoritmos de busca: - Busca cega: Explora o espa\u00e7o de solu\u00e7\u00e3o sem informa\u00e7\u00e3o adicional sobre o objetivo. Exemplos incluem busca em largura e profundidade. - Busca informada: Utiliza heur\u00edsticas para guiar a busca de forma mais eficiente. Algoritmos como A* e Best-First Search s\u00e3o exemplos dessa abordagem.</p> <p>Conforme Nilsson (1982), a escolha do algoritmo \u00e9 essencial para o desempenho do agente, especialmente em espa\u00e7os de solu\u00e7\u00e3o muito grandes.</p>"},{"location":"#4-execucao","title":"4. Execu\u00e7\u00e3o","text":"<p>Uma vez identificado o melhor caminho, o agente passa para a etapa de execu\u00e7\u00e3o. Durante essa fase, \u00e9 essencial que o agente monitore e se adapte \u00e0s condi\u00e7\u00f5es do ambiente, especialmente em cen\u00e1rios din\u00e2micos ou imprevis\u00edveis. Ghallab, Nau e Traverso (2004) destacam que a capacidade de rea\u00e7\u00e3o e adapta\u00e7\u00e3o \u00e9 um dos fatores mais cr\u00edticos para a efic\u00e1cia de agentes em ambientes reais.</p>"},{"location":"#problemas-de-malha-aberta-e-malha-fechada","title":"Problemas de Malha Aberta e Malha Fechada","text":"<p>A abordagem do agente em rela\u00e7\u00e3o ao controle do ambiente pode ser categorizada em dois tipos principais: malha aberta e malha fechada. Essa distin\u00e7\u00e3o \u00e9 essencial para determinar a capacidade do agente de lidar com diferentes tipos de problemas e ambientes.</p>"},{"location":"#1-sistemas-de-malha-aberta","title":"1. Sistemas de Malha Aberta","text":"<p>Em sistemas de malha aberta, as a\u00e7\u00f5es do agente n\u00e3o dependem de feedback do ambiente. Isso significa que o agente executa seu plano sem verificar se as condi\u00e7\u00f5es mudaram ou se o objetivo foi alcan\u00e7ado. Essa abordagem funciona bem em ambientes: - Determin\u00edsticos: Onde as condi\u00e7\u00f5es n\u00e3o mudam de forma inesperada. - Previs\u00edveis: Onde \u00e9 poss\u00edvel planejar todas as a\u00e7\u00f5es antecipadamente.</p> <p>Por exemplo, em uma esteira de montagem industrial, cada etapa \u00e9 executada de forma fixa, sem necessidade de adapta\u00e7\u00e3o.</p>"},{"location":"#2-sistemas-de-malha-fechada","title":"2. Sistemas de Malha Fechada","text":"<p>Em contrapartida, sistemas de malha fechada utilizam feedback constante do ambiente para ajustar as a\u00e7\u00f5es do agente. Esse tipo de controle \u00e9 essencial em cen\u00e1rios: - Din\u00e2micos: Onde o ambiente pode mudar durante a execu\u00e7\u00e3o do plano. - N\u00e3o determin\u00edsticos: Onde os resultados das a\u00e7\u00f5es podem ser incertos.</p> <p>Por exemplo, em um rob\u00f4 que limpa uma sala, o sistema de malha fechada permite que ele ajuste sua rota caso encontre obst\u00e1culos inesperados.</p>"},{"location":"#comparativo","title":"Comparativo","text":"Caracter\u00edstica Malha Aberta Malha Fechada Depend\u00eancia de feedback N\u00e3o Sim Ambiente ideal Determin\u00edstico e previs\u00edvel Din\u00e2mico e n\u00e3o determin\u00edstico Flexibilidade Baixa Alta Exemplo Esteira de montagem Rob\u00f4 aut\u00f4nomo de limpeza <p>Compreender essas diferen\u00e7as \u00e9 crucial para projetar agentes adequados a cada tipo de ambiente, garantindo o melhor desempenho poss\u00edvel.</p>"},{"location":"#algoritmos-de-busca","title":"Algoritmos de Busca","text":"<p>Os algoritmos de busca s\u00e3o fundamentais para resolver problemas, permitindo explorar o espa\u00e7o de estados e encontrar solu\u00e7\u00f5es para atingir os objetivos de um agente.</p>"},{"location":"#1-busca-cega-nao-informada","title":"1. Busca Cega (N\u00e3o Informada)","text":"<p>A Busca Cega explora o espa\u00e7o de estados de forma sistem\u00e1tica e exaustiva, sem considerar informa\u00e7\u00f5es adicionais sobre o objetivo. Esses algoritmos s\u00e3o f\u00e1ceis de implementar, mas podem ser ineficientes em espa\u00e7os de busca muito grandes. Os principais algoritmos de busca cega s\u00e3o:</p>"},{"location":"#11-busca-em-largura-bfs","title":"1.1 Busca em Largura (BFS)","text":"<p>A Busca em Largura explora todos os n\u00f3s de um n\u00edvel antes de passar para o pr\u00f3ximo. \u00c9 garantido que ela encontra a solu\u00e7\u00e3o mais curta (\u00f3tima), desde que os custos entre os passos sejam iguais. No entanto, exige bastante mem\u00f3ria para armazenar os n\u00f3s visitados.</p> <pre><code>from collections import deque\n\ndef bfs(graph, start, goal):\n    visited = set()  # N\u00f3s j\u00e1 visitados\n    queue = deque([(start, [start])])  # Fila de (n\u00f3 atual, caminho at\u00e9 ele)\n\n    while queue:\n        node, path = queue.popleft()  # Remove o primeiro elemento da fila\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        if node == goal:\n            return path  # Caminho encontrado\n\n        for neighbor in graph.get(node, []):  # Adiciona vizinhos \u00e0 fila\n            queue.append((neighbor, path + [neighbor]))\n\n    return None  # Nenhum caminho encontrado\n</code></pre>"},{"location":"#12-busca-em-profundidade-dfs","title":"1.2 Busca em Profundidade (DFS)","text":"<p>A Busca em Profundidade explora os caminhos at\u00e9 o fim antes de retornar e tentar alternativas. Usa menos mem\u00f3ria do que BFS, mas n\u00e3o garante encontrar o caminho mais curto.</p> <pre><code>def dfs(graph, start, goal, path=None, visited=None):\n    if path is None:\n        path = [start]  # Caminho atual\n    if visited is None:\n        visited = set()  # N\u00f3s visitados\n\n    visited.add(start)\n\n    if start == goal:\n        return path  # Caminho encontrado\n\n    for neighbor in graph.get(start, []):\n        if neighbor not in visited:\n            new_path = dfs(graph, neighbor, goal, path + [neighbor], visited)\n            if new_path:\n                return new_path\n\n    return None  # Nenhum caminho encontrado\n</code></pre>"},{"location":"#2-busca-informada-heuristica","title":"2. Busca Informada (Heur\u00edstica)","text":"<p>A Busca Informada utiliza heur\u00edsticas, ou seja, informa\u00e7\u00f5es adicionais sobre o problema, para guiar a explora\u00e7\u00e3o do espa\u00e7o de estados. Isso permite priorizar os caminhos mais promissores, reduzindo o custo de processamento. Os principais algoritmos incluem Best-First Search (explorado em sala) e A*.</p>"},{"location":"#21-best-first-search","title":"2.1 Best-First Search","text":"<p>O algoritmo Best-First Search utiliza uma fun\u00e7\u00e3o heur\u00edstica ( h(n) ) para determinar a prioridade de explora\u00e7\u00e3o dos n\u00f3s. Ele n\u00e3o considera o custo acumulado do caminho e, portanto, pode n\u00e3o encontrar a solu\u00e7\u00e3o \u00f3tima.</p> <pre><code>import heapq\n\ndef best_first_search(graph, heuristics, start, goal):\n    visited = set()\n    queue = [(heuristics[start], start, [start])]  # Fila de prioridade (h(n), n\u00f3, caminho)\n\n    while queue:\n        _, node, path = heapq.heappop(queue)  # Remove o n\u00f3 com menor h(n)\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        if node == goal:\n            return path  # Caminho encontrado\n\n        for neighbor in graph.get(node, []):\n            if neighbor not in visited:\n                heapq.heappush(queue, (heuristics[neighbor], neighbor, path + [neighbor]))\n\n    return None  # Nenhum caminho encontrado\n</code></pre>"},{"location":"#22-algoritmo-a","title":"2.2 Algoritmo A*","text":"<p>O A* combina o custo acumulado ( g(n) ) com a heur\u00edstica ( h(n) ), buscando minimizar o custo total estimado ( f(n) = g(n) + h(n) ). Esse algoritmo garante a solu\u00e7\u00e3o \u00f3tima se ( h(n) ) for admiss\u00edvel (n\u00e3o superestimar o custo real).</p> <pre><code>def a_star(graph, costs, heuristics, start, goal):\n    visited = set()\n    queue = [(heuristics[start], 0, start, [start])]  # Fila de prioridade (f(n), g(n), n\u00f3, caminho)\n\n    while queue:\n        _, cost, node, path = heapq.heappop(queue)  # Remove o n\u00f3 com menor f(n)\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        if node == goal:\n            return path  # Caminho encontrado\n\n        for neighbor, weight in graph.get(node, []):  # Adiciona vizinhos\n            if neighbor not in visited:\n                total_cost = cost + weight\n                heapq.heappush(queue, (total_cost + heuristics[neighbor], total_cost, neighbor, path + [neighbor]))\n\n    return None  # Nenhum caminho encontrado\n</code></pre>"},{"location":"#funcoes-heuristicas","title":"Fun\u00e7\u00f5es Heur\u00edsticas","text":"<p>As fun\u00e7\u00f5es heur\u00edsticas s\u00e3o um componente essencial dos algoritmos de busca informada, como o Best-First Search e o A*. Elas fornecem uma maneira de estimar qu\u00e3o perto um estado est\u00e1 do objetivo, ajudando os algoritmos a fazer escolhas mais inteligentes sobre qual caminho seguir. As heur\u00edsticas desempenham um papel crucial na efici\u00eancia e efic\u00e1cia desses algoritmos, pois permitem que a busca seja orientada para as solu\u00e7\u00f5es mais promissoras, ao inv\u00e9s de explorar todos os caminhos de forma cega.</p>"},{"location":"#definicao-de-heuristica","title":"Defini\u00e7\u00e3o de Heur\u00edstica","text":"<p>Uma heur\u00edstica \u00e9 uma fun\u00e7\u00e3o que atribui um valor a cada n\u00f3 de um espa\u00e7o de busca, indicando a \"aproximidade\" desse n\u00f3 em rela\u00e7\u00e3o ao objetivo. O valor retornado pela fun\u00e7\u00e3o heur\u00edstica deve ser uma estimativa do custo para alcan\u00e7ar o objetivo a partir do estado avaliado.</p> <p>Exemplos de fun\u00e7\u00f5es heur\u00edsticas: - Dist\u00e2ncia Euclidiana ou Manhattan: Em problemas de navega\u00e7\u00e3o, a heur\u00edstica pode ser a dist\u00e2ncia direta entre o n\u00f3 atual e o objetivo. A escolha depende do tipo de movimento permitido. - N\u00famero de blocos fora do lugar: Em problemas como o quebra-cabe\u00e7a 8 (ou 15), a heur\u00edstica pode ser o n\u00famero de pe\u00e7as fora do lugar, ou seja, quantas pe\u00e7as precisam ser movidas para resolver o quebra-cabe\u00e7a. - Custo de a\u00e7\u00e3o restante: Em problemas de otimiza\u00e7\u00e3o, pode-se utilizar o custo estimado das a\u00e7\u00f5es restantes para alcan\u00e7ar o objetivo.</p> <p>A heur\u00edstica precisa ser admiss\u00edvel e, em muitos casos, consistente (tamb\u00e9m chamada de mon\u00f3tona) para garantir que o algoritmo A* seja \u00f3timo:</p> <ul> <li>Admissibilidade: Uma heur\u00edstica \u00e9 admiss\u00edvel se nunca superestima o custo real de alcan\u00e7ar o objetivo. Isso significa que, para qualquer n\u00f3, o valor estimado pela heur\u00edstica deve ser menor ou igual ao custo real m\u00ednimo at\u00e9 o objetivo.</li> <li>Consist\u00eancia (ou Monotonicidade): Uma heur\u00edstica \u00e9 consistente se, para cada n\u00f3 e cada sucessor do n\u00f3, a diferen\u00e7a entre os valores heur\u00edsticos n\u00e3o for maior do que o custo real de mover entre eles.</li> </ul>"},{"location":"#exemplos-de-funcoes-heuristicas","title":"Exemplos de Fun\u00e7\u00f5es Heur\u00edsticas","text":"<ol> <li> <p>Dist\u00e2ncia Euclidiana (para navega\u00e7\u00e3o em um espa\u00e7o 2D):    Usada em problemas de navega\u00e7\u00e3o em um espa\u00e7o cont\u00ednuo, considerando a dist\u00e2ncia direta entre o n\u00f3 atual e o objetivo.</p> </li> <li> <p>Dist\u00e2ncia Manhattan (para navega\u00e7\u00e3o em um espa\u00e7o 2D com movimento em grade):    Aplic\u00e1vel em grades, quando o movimento \u00e9 restrito a dire\u00e7\u00f5es horizontais e verticais, acumulando as dist\u00e2ncias percorridas em cada eixo.</p> </li> <li> <p>N\u00famero de blocos fora do lugar (para o quebra-cabe\u00e7a 8 ou 15):    Considera o n\u00famero de pe\u00e7as que est\u00e3o fora das suas posi\u00e7\u00f5es corretas. \u00c9 uma estimativa simples e eficaz para medir o progresso em dire\u00e7\u00e3o \u00e0 solu\u00e7\u00e3o.</p> </li> <li> <p>Custo de a\u00e7\u00f5es restantes (em problemas de otimiza\u00e7\u00e3o):    Em problemas como roteamento de ve\u00edculos, essa heur\u00edstica pode estimar o custo das a\u00e7\u00f5es restantes necess\u00e1rias para alcan\u00e7ar o objetivo.</p> </li> </ol>"},{"location":"#as-funcoes-heuristicas-sao-ferramentas-poderosas-para-guiar-a-busca-em-problemas-complexos-elas-permitem-que-os-algoritmos-de-busca-informada-como-o-a-escolham-de-forma-inteligente-os-caminhos-mais-promissores-melhorando-a-eficiencia-e-a-precisao-na-busca-pela-solucao-otima-a-escolha-da-heuristica-adequada-e-crucial-para-o-desempenho-do-algoritmo-e-deve-ser-cuidadosamente-selecionada-com-base-nas-caracteristicas-do-problema-em-questao","title":"As fun\u00e7\u00f5es heur\u00edsticas s\u00e3o ferramentas poderosas para guiar a busca em problemas complexos. Elas permitem que os algoritmos de busca informada, como o A*, escolham de forma inteligente os caminhos mais promissores, melhorando a efici\u00eancia e a precis\u00e3o na busca pela solu\u00e7\u00e3o \u00f3tima. A escolha da heur\u00edstica adequada \u00e9 crucial para o desempenho do algoritmo, e deve ser cuidadosamente selecionada com base nas caracter\u00edsticas do problema em quest\u00e3o.","text":""},{"location":"#busca-em-ambientes-complexos","title":"Busca em Ambientes Complexos","text":"<p>Em alguns problemas de Intelig\u00eancia Artificial, a busca no espa\u00e7o de estados n\u00e3o se concentra na trajet\u00f3ria ou caminho percorrido at\u00e9 o objetivo, mas sim no pr\u00f3prio estado final que atende \u00e0s condi\u00e7\u00f5es de sucesso. Isso \u00e9 particularmente importante em problemas onde o objetivo final \u00e9 mais relevante do que o caminho para alcan\u00e7\u00e1-lo.</p>"},{"location":"#contextualizando-a-busca-em-ambientes-complexos","title":"Contextualizando a Busca em Ambientes Complexos","text":"<p>Nos ambientes complexos, a busca visa encontrar uma solu\u00e7\u00e3o ou um estado final que satisfa\u00e7a as condi\u00e7\u00f5es do problema, mas sem necessariamente se preocupar com o caminho para chegar at\u00e9 esse estado. Em muitos casos, o n\u00famero de estados poss\u00edveis \u00e9 muito grande e a solu\u00e7\u00e3o pode envolver uma otimiza\u00e7\u00e3o de v\u00e1rios fatores simultaneamente.</p> <p>Exemplos de problemas que se encaixam nesse tipo de abordagem incluem:</p> <ul> <li>Projeto de Circuito Integrado: Encontrar uma configura\u00e7\u00e3o eficiente de um circuito sem necessariamente se preocupar com a ordem exata das etapas.</li> <li>Layout de Ch\u00e3o de F\u00e1brica: Determinar a disposi\u00e7\u00e3o ideal das m\u00e1quinas e departamentos, visando minimizar o custo de movimenta\u00e7\u00e3o de materiais e aumentar a efici\u00eancia.</li> <li>Programa\u00e7\u00e3o Autom\u00e1tica: Alocar tarefas de maneira eficiente a um conjunto de recursos, como em escalonamento de processos ou distribui\u00e7\u00e3o de tarefas em um cluster de servidores.</li> <li>Otimiza\u00e7\u00e3o de Rede de Telecomunica\u00e7\u00f5es: Maximizar a largura de banda ou minimizar a lat\u00eancia de uma rede, sem se preocupar diretamente com o caminho individual dos pacotes de dados.</li> <li>Planejamento de Safra: Definir as melhores safras a serem plantadas em uma \u00e1rea, levando em considera\u00e7\u00e3o fatores como clima, solo e demanda de mercado.</li> <li>Gerenciamento de Portf\u00f3lio: Determinar a melhor aloca\u00e7\u00e3o de ativos financeiros (a\u00e7\u00f5es, t\u00edtulos, etc.) com o objetivo de maximizar o retorno esperado ou minimizar o risco.</li> </ul> <p>Em problemas dessa natureza, a busca \u00e9 muitas vezes associada a t\u00e9cnicas de otimiza\u00e7\u00e3o e aproxima\u00e7\u00e3o, e os m\u00e9todos de busca podem ser adaptados para explorar rapidamente grandes espa\u00e7os de solu\u00e7\u00f5es poss\u00edveis. A busca n\u00e3o visa um caminho, mas sim o estado final mais adequado ou otimizado.</p>"},{"location":"#tecnicas-de-busca-em-ambientes-complexos","title":"T\u00e9cnicas de Busca em Ambientes Complexos","text":"<p>Aqui est\u00e3o algumas abordagens usadas na busca em ambientes complexos:</p> <ol> <li>Algoritmos de Busca Local (Local Search)</li> <li>Algoritmos Gen\u00e9ticos (Genetic Algorithms)</li> <li>Simulated Annealing</li> <li>Algoritmos de Programa\u00e7\u00e3o Linear</li> </ol>"},{"location":"#exemplo-de-simulated-annealing","title":"Exemplo de Simulated Annealing","text":"<p>Simulated Annealing (SA) \u00e9 um algoritmo de otimiza\u00e7\u00e3o inspirado no processo f\u00edsico de resfriamento de metais. A ideia \u00e9 explorar solu\u00e7\u00f5es de forma aleat\u00f3ria, aceitando solu\u00e7\u00f5es piores de forma controlada, para escapar de m\u00ednimos locais e alcan\u00e7ar uma solu\u00e7\u00e3o globalmente \u00f3tima.</p>"},{"location":"#exemplo-o-problema-de-minimizacao-de-funcao","title":"Exemplo: O Problema de Minimiza\u00e7\u00e3o de Fun\u00e7\u00e3o","text":"<pre><code>import math\nimport random\n\ndef objective_function(x):\n    return x**2 + 10*math.sin(x)  # Fun\u00e7\u00e3o objetivo: minimizar f(x)\n\ndef simulated_annealing(start, temperature, cooling_rate):\n    current_solution = start\n    current_cost = objective_function(current_solution)\n\n    while temperature &gt; 1:\n        new_solution = current_solution + random.uniform(-1, 1)\n        new_cost = objective_function(new_solution)\n\n        # Aceita a nova solu\u00e7\u00e3o com base na temperatura\n        if new_cost &lt; current_cost or random.random() &lt; math.exp((current_cost - new_cost) / temperature):\n            current_solution = new_solution\n            current_cost = new_cost\n\n        temperature *= cooling_rate  # Diminui a temperatura\n\n    return current_solution, current_cost\n\n# Exemplo de uso\nstart = 10\ntemperature = 1000\ncooling_rate = 0.995\nsolution, cost = simulated_annealing(start, temperature, cooling_rate)\nprint(f\"Solu\u00e7\u00e3o final: {solution\n\n}, Custo: {cost}\")\n</code></pre> <p>Neste exemplo, \u00e9 usado Simulated Annealing para minimizar uma fun\u00e7\u00e3o matem\u00e1tica. O algoritmo explora novas solu\u00e7\u00f5es e aceita solu\u00e7\u00f5es piores com uma probabilidade que diminui com o tempo (temperatura), ajudando a escapar de m\u00ednimos locais.</p>"},{"location":"#algoritmos-geneticos-algoritmos-evolutivos","title":"Algoritmos Gen\u00e9ticos (Algoritmos Evolutivos)","text":"<p>Os Algoritmos Gen\u00e9ticos s\u00e3o t\u00e9cnicas de otimiza\u00e7\u00e3o inspiradas na evolu\u00e7\u00e3o natural. Eles trabalham com uma popula\u00e7\u00e3o de indiv\u00edduos, onde cada indiv\u00edduo representa uma solu\u00e7\u00e3o poss\u00edvel. Os indiv\u00edduos mais aptos, avaliados por uma fun\u00e7\u00e3o de fitness, reproduzem-se atrav\u00e9s de recombina\u00e7\u00e3o e muta\u00e7\u00e3o para formar a pr\u00f3xima gera\u00e7\u00e3o. Esse processo se repete at\u00e9 alcan\u00e7ar uma solu\u00e7\u00e3o satisfat\u00f3ria.</p> <pre><code>import random\n\ndef fitness(individual):\n    return sum(individual)\n\ndef mutate(individual):\n    idx = random.randint(0, len(individual)-1)\n    individual[idx] = 1 - individual[idx]\n    return individual\n\ndef crossover(parent1, parent2):\n    point = random.randint(1, len(parent1)-1)\n    return parent1[:point] + parent2[point:]\n\n# Inicializa\u00e7\u00e3o\npopulation = [[random.randint(0,1) for _ in range(6)] for _ in range(4)]\n\n# Evolu\u00e7\u00e3o\nfor generation in range(5):\n    population = sorted(population, key=fitness, reverse=True)\n    print(f'Gera\u00e7\u00e3o {generation}: {population}')\n    next_gen = population[:2]\n    while len(next_gen) &lt; 4:\n        parent1, parent2 = random.sample(next_gen, 2)\n        child = crossover(parent1, parent2)\n        child = mutate(child)\n        next_gen.append(child)\n    population = next_gen\n</code></pre> <p>Refer\u00eancias</p> <ul> <li>Russell, S., &amp; Norvig, P. (2010). Artificial Intelligence: A Modern Approach (3\u00aa ed.). Prentice Hall.</li> <li>Ghallab, M., Nau, D., &amp; Traverso, P. (2004). Automated Planning: Theory and Practice. Morgan Kaufmann.</li> <li>Nilsson, N.J. (1982). Principles of Artificial Intelligence. Tioga Publishing Co.</li> <li>Holland, J. H. (1975). Adaptation in Natural and Artificial Systems.</li> <li>Goldberg, D. E. (1989). Genetic Algorithms in Search, Optimization, and Machine Learning.</li> <li>Mitchell, M. (1998). An Introduction to Genetic Algorithms.</li> </ul>"}]}