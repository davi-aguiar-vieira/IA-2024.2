
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.45">
    
    
      
        <title>IA</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.0253249f.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="purple">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#portfolio-2-inteligencia-artificial" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="IA" class="md-header__button md-logo" aria-label="IA" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            IA
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Portfólio 2 - Inteligência Artificial
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="purple"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="teal" data-md-color-accent="lime"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="." class="md-tabs__link">
        
  
    
  
  Portfólio 2 - Inteligência Artificial

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="IA" class="md-nav__button md-logo" aria-label="IA" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    IA
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Portfólio 2 - Inteligência Artificial
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="." class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Portfólio 2 - Inteligência Artificial
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#agente-de-solucoes-de-problemas" class="md-nav__link">
    <span class="md-ellipsis">
      Agente de Soluções de Problemas
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Agente de Soluções de Problemas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-formulacao-de-objetivos" class="md-nav__link">
    <span class="md-ellipsis">
      1. Formulação de Objetivos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-formulacao-do-problema" class="md-nav__link">
    <span class="md-ellipsis">
      2. Formulação do Problema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-busca" class="md-nav__link">
    <span class="md-ellipsis">
      3. Busca
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4-execucao" class="md-nav__link">
    <span class="md-ellipsis">
      4. Execução
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#problemas-de-malha-aberta-e-malha-fechada" class="md-nav__link">
    <span class="md-ellipsis">
      Problemas de Malha Aberta e Malha Fechada
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Problemas de Malha Aberta e Malha Fechada">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-sistemas-de-malha-aberta" class="md-nav__link">
    <span class="md-ellipsis">
      1. Sistemas de Malha Aberta
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-sistemas-de-malha-fechada" class="md-nav__link">
    <span class="md-ellipsis">
      2. Sistemas de Malha Fechada
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comparativo" class="md-nav__link">
    <span class="md-ellipsis">
      Comparativo
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#algoritmos-de-busca" class="md-nav__link">
    <span class="md-ellipsis">
      Algoritmos de Busca
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Algoritmos de Busca">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-busca-cega-nao-informada" class="md-nav__link">
    <span class="md-ellipsis">
      1. Busca Cega (Não Informada)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="1. Busca Cega (Não Informada)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-busca-em-largura-bfs" class="md-nav__link">
    <span class="md-ellipsis">
      1.1 Busca em Largura (BFS)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-busca-em-profundidade-dfs" class="md-nav__link">
    <span class="md-ellipsis">
      1.2 Busca em Profundidade (DFS)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-busca-informada-heuristica" class="md-nav__link">
    <span class="md-ellipsis">
      2. Busca Informada (Heurística)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2. Busca Informada (Heurística)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-best-first-search" class="md-nav__link">
    <span class="md-ellipsis">
      2.1 Best-First Search
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-algoritmo-a" class="md-nav__link">
    <span class="md-ellipsis">
      2.2 Algoritmo A*
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#funcoes-heuristicas" class="md-nav__link">
    <span class="md-ellipsis">
      Funções Heurísticas
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Funções Heurísticas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicao-de-heuristica" class="md-nav__link">
    <span class="md-ellipsis">
      Definição de Heurística
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exemplos-de-funcoes-heuristicas" class="md-nav__link">
    <span class="md-ellipsis">
      Exemplos de Funções Heurísticas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#busca-em-ambientes-complexos" class="md-nav__link">
    <span class="md-ellipsis">
      Busca em Ambientes Complexos
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Busca em Ambientes Complexos">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#contextualizando-a-busca-em-ambientes-complexos" class="md-nav__link">
    <span class="md-ellipsis">
      Contextualizando a Busca em Ambientes Complexos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tecnicas-de-busca-em-ambientes-complexos" class="md-nav__link">
    <span class="md-ellipsis">
      Técnicas de Busca em Ambientes Complexos
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exemplo-de-simulated-annealing" class="md-nav__link">
    <span class="md-ellipsis">
      Exemplo de Simulated Annealing
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Exemplo de Simulated Annealing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#exemplo-o-problema-de-minimizacao-de-funcao" class="md-nav__link">
    <span class="md-ellipsis">
      Exemplo: O Problema de Minimização de Função
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#algoritmos-geneticos-algoritmos-evolutivos" class="md-nav__link">
    <span class="md-ellipsis">
      Algoritmos Genéticos (Algoritmos Evolutivos)
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="portfolio-2-inteligencia-artificial">Portfólio 2 - Inteligência Artificial</h1>
<h2 id="agente-de-solucoes-de-problemas"><strong>Agente de Soluções de Problemas</strong></h2>
<p>Um agente de solução de problemas é uma entidade autônoma projetada para atuar em um ambiente com o objetivo de atingir metas definidas. Ele segue um processo sistemático para identificar, analisar e resolver problemas. Esses agentes são fundamentais na Inteligência Artificial (IA), sendo aplicados em áreas como tomada de decisão, planejamento e automação.</p>
<h3 id="1-formulacao-de-objetivos"><strong>1. Formulação de Objetivos</strong></h3>
<p>A formulação de objetivos é a etapa inicial onde as metas são claramente definidas. Objetivos bem delineados orientam todas as fases seguintes, garantindo que os esforços do agente sejam direcionados eficientemente. Segundo <strong>Russell e Norvig (2010)</strong>, a qualidade dessa formulação afeta diretamente a eficiência do processo de solução de problemas.</p>
<h3 id="2-formulacao-do-problema"><strong>2. Formulação do Problema</strong></h3>
<p>Na formulação do problema, o agente descreve os elementos necessários para resolvê-lo, incluindo:</p>
<ul>
<li><strong>Estado inicial</strong>: Situação atual do sistema.</li>
<li><strong>Estados objetivos</strong>: Condições que representam o sucesso.</li>
<li><strong>Ações possíveis</strong>: Conjunto de operações ou movimentos que o agente pode executar.</li>
<li><strong>Função de custo</strong>: Avalia o esforço ou custo associado a cada ação.</li>
</ul>
<p>Por exemplo, em um jogo de xadrez, o estado inicial é a disposição das peças no tabuleiro, os estados objetivos incluem situações como xeque-mate, e as ações possíveis correspondem aos movimentos permitidos para cada peça.</p>
<h3 id="3-busca"><strong>3. Busca</strong></h3>
<p>A busca é a etapa onde o agente explora o espaço de soluções em busca do caminho mais eficiente para atingir o objetivo. Isso é feito de forma simulada, antes da execução real das ações.</p>
<p><strong>Classificação de algoritmos de busca:</strong>
- <strong>Busca cega</strong>: Explora o espaço de solução sem informação adicional sobre o objetivo. Exemplos incluem busca em largura e profundidade.
- <strong>Busca informada</strong>: Utiliza heurísticas para guiar a busca de forma mais eficiente. Algoritmos como A* e Best-First Search são exemplos dessa abordagem.</p>
<p>Conforme <strong>Nilsson (1982)</strong>, a escolha do algoritmo é essencial para o desempenho do agente, especialmente em espaços de solução muito grandes.</p>
<h3 id="4-execucao"><strong>4. Execução</strong></h3>
<p>Uma vez identificado o melhor caminho, o agente passa para a etapa de execução. Durante essa fase, é essencial que o agente monitore e se adapte às condições do ambiente, especialmente em cenários dinâmicos ou imprevisíveis. <strong>Ghallab, Nau e Traverso (2004)</strong> destacam que a capacidade de reação e adaptação é um dos fatores mais críticos para a eficácia de agentes em ambientes reais.</p>
<hr />
<h2 id="problemas-de-malha-aberta-e-malha-fechada"><strong>Problemas de Malha Aberta e Malha Fechada</strong></h2>
<p>A abordagem do agente em relação ao controle do ambiente pode ser categorizada em dois tipos principais: <strong>malha aberta</strong> e <strong>malha fechada</strong>. Essa distinção é essencial para determinar a capacidade do agente de lidar com diferentes tipos de problemas e ambientes.</p>
<h3 id="1-sistemas-de-malha-aberta"><strong>1. Sistemas de Malha Aberta</strong></h3>
<p>Em sistemas de malha aberta, as ações do agente não dependem de feedback do ambiente. Isso significa que o agente executa seu plano sem verificar se as condições mudaram ou se o objetivo foi alcançado. Essa abordagem funciona bem em ambientes:
- <strong>Determinísticos</strong>: Onde as condições não mudam de forma inesperada.
- <strong>Previsíveis</strong>: Onde é possível planejar todas as ações antecipadamente.</p>
<p>Por exemplo, em uma esteira de montagem industrial, cada etapa é executada de forma fixa, sem necessidade de adaptação.</p>
<h3 id="2-sistemas-de-malha-fechada"><strong>2. Sistemas de Malha Fechada</strong></h3>
<p>Em contrapartida, sistemas de malha fechada utilizam feedback constante do ambiente para ajustar as ações do agente. Esse tipo de controle é essencial em cenários:
- <strong>Dinâmicos</strong>: Onde o ambiente pode mudar durante a execução do plano.
- <strong>Não determinísticos</strong>: Onde os resultados das ações podem ser incertos.</p>
<p>Por exemplo, em um robô que limpa uma sala, o sistema de malha fechada permite que ele ajuste sua rota caso encontre obstáculos inesperados.</p>
<h3 id="comparativo"><strong>Comparativo</strong></h3>
<table>
<thead>
<tr>
<th>Característica</th>
<th>Malha Aberta</th>
<th>Malha Fechada</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dependência de feedback</td>
<td>Não</td>
<td>Sim</td>
</tr>
<tr>
<td>Ambiente ideal</td>
<td>Determinístico e previsível</td>
<td>Dinâmico e não determinístico</td>
</tr>
<tr>
<td>Flexibilidade</td>
<td>Baixa</td>
<td>Alta</td>
</tr>
<tr>
<td>Exemplo</td>
<td>Esteira de montagem</td>
<td>Robô autônomo de limpeza</td>
</tr>
</tbody>
</table>
<p>Compreender essas diferenças é crucial para projetar agentes adequados a cada tipo de ambiente, garantindo o melhor desempenho possível.</p>
<hr />
<h2 id="algoritmos-de-busca">Algoritmos de Busca</h2>
<p>Os algoritmos de busca são fundamentais para resolver problemas, permitindo explorar o espaço de estados e encontrar soluções para atingir os objetivos de um agente.</p>
<h3 id="1-busca-cega-nao-informada"><strong>1. Busca Cega (Não Informada)</strong></h3>
<p>A Busca Cega explora o espaço de estados de forma sistemática e exaustiva, sem considerar informações adicionais sobre o objetivo. Esses algoritmos são fáceis de implementar, mas podem ser ineficientes em espaços de busca muito grandes. Os principais algoritmos de busca cega são:</p>
<h4 id="11-busca-em-largura-bfs"><strong>1.1 Busca em Largura (BFS)</strong></h4>
<p>A <strong>Busca em Largura</strong> explora todos os nós de um nível antes de passar para o próximo. É garantido que ela encontra a solução mais curta (ótima), desde que os custos entre os passos sejam iguais. No entanto, exige bastante memória para armazenar os nós visitados.</p>
<pre><code class="language-python">from collections import deque

def bfs(graph, start, goal):
    visited = set()  # Nós já visitados
    queue = deque([(start, [start])])  # Fila de (nó atual, caminho até ele)

    while queue:
        node, path = queue.popleft()  # Remove o primeiro elemento da fila

        if node in visited:
            continue
        visited.add(node)

        if node == goal:
            return path  # Caminho encontrado

        for neighbor in graph.get(node, []):  # Adiciona vizinhos à fila
            queue.append((neighbor, path + [neighbor]))

    return None  # Nenhum caminho encontrado
</code></pre>
<hr />
<h4 id="12-busca-em-profundidade-dfs"><strong>1.2 Busca em Profundidade (DFS)</strong></h4>
<p>A <strong>Busca em Profundidade</strong> explora os caminhos até o fim antes de retornar e tentar alternativas. Usa menos memória do que BFS, mas não garante encontrar o caminho mais curto.</p>
<pre><code class="language-python">def dfs(graph, start, goal, path=None, visited=None):
    if path is None:
        path = [start]  # Caminho atual
    if visited is None:
        visited = set()  # Nós visitados

    visited.add(start)

    if start == goal:
        return path  # Caminho encontrado

    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            new_path = dfs(graph, neighbor, goal, path + [neighbor], visited)
            if new_path:
                return new_path

    return None  # Nenhum caminho encontrado
</code></pre>
<hr />
<h3 id="2-busca-informada-heuristica"><strong>2. Busca Informada (Heurística)</strong></h3>
<p>A Busca Informada utiliza heurísticas, ou seja, informações adicionais sobre o problema, para guiar a exploração do espaço de estados. Isso permite priorizar os caminhos mais promissores, reduzindo o custo de processamento. Os principais algoritmos incluem <strong>Best-First Search</strong> (explorado em sala) e <strong>A</strong>*.</p>
<h4 id="21-best-first-search"><strong>2.1 Best-First Search</strong></h4>
<p>O algoritmo <strong>Best-First Search</strong> utiliza uma função heurística ( h(n) ) para determinar a prioridade de exploração dos nós. Ele não considera o custo acumulado do caminho e, portanto, pode não encontrar a solução ótima.</p>
<pre><code class="language-python">import heapq

def best_first_search(graph, heuristics, start, goal):
    visited = set()
    queue = [(heuristics[start], start, [start])]  # Fila de prioridade (h(n), nó, caminho)

    while queue:
        _, node, path = heapq.heappop(queue)  # Remove o nó com menor h(n)

        if node in visited:
            continue
        visited.add(node)

        if node == goal:
            return path  # Caminho encontrado

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                heapq.heappush(queue, (heuristics[neighbor], neighbor, path + [neighbor]))

    return None  # Nenhum caminho encontrado
</code></pre>
<hr />
<h4 id="22-algoritmo-a"><strong>2.2 Algoritmo A</strong>*</h4>
<p>O <strong>A</strong>* combina o custo acumulado ( g(n) ) com a heurística ( h(n) ), buscando minimizar o custo total estimado ( f(n) = g(n) + h(n) ). Esse algoritmo garante a solução ótima se ( h(n) ) for admissível (não superestimar o custo real).</p>
<pre><code class="language-python">def a_star(graph, costs, heuristics, start, goal):
    visited = set()
    queue = [(heuristics[start], 0, start, [start])]  # Fila de prioridade (f(n), g(n), nó, caminho)

    while queue:
        _, cost, node, path = heapq.heappop(queue)  # Remove o nó com menor f(n)

        if node in visited:
            continue
        visited.add(node)

        if node == goal:
            return path  # Caminho encontrado

        for neighbor, weight in graph.get(node, []):  # Adiciona vizinhos
            if neighbor not in visited:
                total_cost = cost + weight
                heapq.heappush(queue, (total_cost + heuristics[neighbor], total_cost, neighbor, path + [neighbor]))

    return None  # Nenhum caminho encontrado
</code></pre>
<hr />
<h2 id="funcoes-heuristicas">Funções Heurísticas</h2>
<p>As <strong>funções heurísticas</strong> são um componente essencial dos algoritmos de busca informada, como o <strong>Best-First Search</strong> e o <strong>A</strong>*. Elas fornecem uma maneira de estimar quão perto um estado está do objetivo, ajudando os algoritmos a fazer escolhas mais inteligentes sobre qual caminho seguir. As heurísticas desempenham um papel crucial na eficiência e eficácia desses algoritmos, pois permitem que a busca seja orientada para as soluções mais promissoras, ao invés de explorar todos os caminhos de forma cega.</p>
<h3 id="definicao-de-heuristica">Definição de Heurística</h3>
<p>Uma <strong>heurística</strong> é uma função ( h(n) ) que atribui um valor a cada nó ( n ) de um espaço de busca, indicando a "aproximidade" desse nó em relação ao objetivo. O valor retornado pela função heurística deve ser uma estimativa do custo para alcançar o objetivo a partir do estado ( n ).</p>
<p><strong>Exemplos de funções heurísticas:</strong>
- <strong>Distância Euclidiana ou Manhattan:</strong> em problemas de navegação, a heurística pode ser a distância direta entre o nó atual e o objetivo (usando a fórmula de distância Euclidiana ou Manhattan, dependendo do tipo de movimento permitido).
- <strong>Número de blocos fora do lugar:</strong> em problemas como o quebra-cabeça 8 (ou 15), a heurística pode ser o número de peças fora do lugar, ou seja, quantas peças precisam ser movidas para resolver o quebra-cabeça.
- <strong>Custo de ação restante:</strong> em problemas de otimização, pode-se utilizar o custo estimado das ações restantes para alcançar o objetivo.</p>
<p>A heurística precisa ser <strong>admissível</strong> e, em muitos casos, <strong>consistente</strong> (também chamada de <strong>monótona</strong>) para garantir que o algoritmo A* seja ótimo:</p>
<ul>
<li><strong>Admissibilidade:</strong> Uma heurística é admissível se nunca superestima o custo real de alcançar o objetivo. Ou seja, para qualquer nó ( n ), a heurística ( h(n) ) deve ser menor ou igual ao custo real mínimo de ( n ) até o objetivo.</li>
<li><strong>Consistência (ou Monotonicidade):</strong> Uma heurística é consistente se, para cada nó ( n ) e cada sucessor ( n' ) de ( n ), a diferença entre a heurística de ( n ) e ( n' ) não for maior do que o custo real para ir de ( n ) para ( n' ). Formalmente, isso significa que:<br />
  ( h(n) \leq c(n, n') + h(n') ),<br />
  onde ( c(n, n') ) é o custo real de mover de ( n ) para ( n' ).</li>
</ul>
<h3 id="exemplos-de-funcoes-heuristicas">Exemplos de Funções Heurísticas</h3>
<p>Aqui estão alguns exemplos de funções heurísticas usadas em algoritmos de busca, com base em diferentes tipos de problemas.</p>
<ol>
<li><strong>Distância Euclidiana (para navegação em um espaço 2D):</strong></li>
</ol>
<p>Para problemas de navegação em um espaço contínuo, a heurística pode ser a distância direta entre o nó atual e o objetivo. A fórmula da distância Euclidiana em 2D é:
   [
   h(n) = \sqrt{(x_n - x_{goal})^2 + (y_n - y_{goal})^2}
   ]
   Onde ( (x_n, y_n) ) são as coordenadas do nó atual e ( (x_{goal}, y_{goal}) ) são as coordenadas do objetivo.</p>
<ol>
<li><strong>Distância Manhattan (para navegação em um espaço 2D com movimento em grade):</strong></li>
</ol>
<p>A distância Manhattan é uma heurística comum quando o movimento é restrito a uma grade (onde se pode mover apenas na horizontal ou vertical). A fórmula é:
   [
   h(n) = |x_n - x_{goal}| + |y_n - y_{goal}|
   ]
   Ela calcula a soma das distâncias absolutas nas direções horizontal e vertical.</p>
<ol>
<li><strong>Número de blocos fora do lugar (para o quebra-cabeça 8 ou 15):</strong></li>
</ol>
<p>Em problemas como o quebra-cabeça, a heurística pode ser o número de peças que não estão no lugar correto. Para cada configuração do quebra-cabeça, o valor da heurística seria o número de peças fora do lugar.</p>
<p>Por exemplo, em um quebra-cabeça 8:
   [
   h(n) = \text{número de peças fora do lugar}
   ]</p>
<ol>
<li><strong>Custo de ações restantes (em problemas de otimização):</strong></li>
</ol>
<p>Em alguns problemas de otimização, a heurística pode ser o custo estimado para completar uma solução. Por exemplo, em um problema de <strong>roteamento de veículos</strong>, a heurística pode ser o custo estimado para percorrer o restante do percurso a partir do nó atual até o destino.</p>
<p>As funções heurísticas são ferramentas poderosas para guiar a busca em problemas complexos. Elas permitem que os algoritmos de busca informada, como o <strong>A</strong>*, escolham de forma inteligente os caminhos mais promissores, melhorando a eficiência e a precisão na busca pela solução ótima. A escolha da heurística adequada é crucial para o desempenho do algoritmo, e deve ser cuidadosamente escolhida com base nas características do problema em questão.</p>
<hr />
<h2 id="busca-em-ambientes-complexos">Busca em Ambientes Complexos</h2>
<p>Em alguns problemas de Inteligência Artificial, a busca no espaço de estados não se concentra na trajetória ou caminho percorrido até o objetivo, mas sim no próprio <strong>estado final</strong> que atende às condições de sucesso. Isso é particularmente importante em problemas onde o objetivo final é mais relevante do que o caminho para alcançá-lo.</p>
<h3 id="contextualizando-a-busca-em-ambientes-complexos">Contextualizando a Busca em Ambientes Complexos</h3>
<p>Nos ambientes complexos, a busca visa <strong>encontrar uma solução ou um estado final que satisfaça as condições do problema</strong>, mas sem necessariamente se preocupar com o caminho para chegar até esse estado. Em muitos casos, o número de estados possíveis é muito grande e a solução pode envolver uma otimização de vários fatores simultaneamente.</p>
<p>Exemplos de problemas que se encaixam nesse tipo de abordagem incluem:</p>
<ul>
<li><strong>Projeto de Circuito Integrado:</strong> Encontrar uma configuração eficiente de um circuito sem necessariamente se preocupar com a ordem exata das etapas.</li>
<li><strong>Layout de Chão de Fábrica:</strong> Determinar a disposição ideal das máquinas e departamentos, visando minimizar o custo de movimentação de materiais e aumentar a eficiência.</li>
<li><strong>Programação Automática:</strong> Alocar tarefas de maneira eficiente a um conjunto de recursos, como em escalonamento de processos ou distribuição de tarefas em um cluster de servidores.</li>
<li><strong>Otimização de Rede de Telecomunicações:</strong> Maximizar a largura de banda ou minimizar a latência de uma rede, sem se preocupar diretamente com o caminho individual dos pacotes de dados.</li>
<li><strong>Planejamento de Safra:</strong> Definir as melhores safras a serem plantadas em uma área, levando em consideração fatores como clima, solo e demanda de mercado.</li>
<li><strong>Gerenciamento de Portfólio:</strong> Determinar a melhor alocação de ativos financeiros (ações, títulos, etc.) com o objetivo de maximizar o retorno esperado ou minimizar o risco.</li>
</ul>
<p>Em problemas dessa natureza, a busca é muitas vezes associada a técnicas de <strong>otimização</strong> e <strong>aproximação</strong>, e os métodos de busca podem ser adaptados para explorar rapidamente grandes espaços de soluções possíveis. A busca não visa um caminho, mas sim o estado final mais adequado ou otimizado.</p>
<h3 id="tecnicas-de-busca-em-ambientes-complexos">Técnicas de Busca em Ambientes Complexos</h3>
<p>Aqui estão algumas abordagens usadas na busca em ambientes complexos:</p>
<ol>
<li><strong>Algoritmos de Busca Local (Local Search)</strong></li>
<li><strong>Algoritmos Genéticos (Genetic Algorithms)</strong></li>
<li><strong>Simulated Annealing</strong></li>
<li><strong>Algoritmos de Programação Linear</strong></li>
</ol>
<h3 id="exemplo-de-simulated-annealing">Exemplo de Simulated Annealing</h3>
<p><strong>Simulated Annealing</strong> (SA) é um algoritmo de otimização inspirado no processo físico de resfriamento de metais. A ideia é explorar soluções de forma aleatória, aceitando soluções piores de forma controlada, para escapar de mínimos locais e alcançar uma solução globalmente ótima.</p>
<h4 id="exemplo-o-problema-de-minimizacao-de-funcao">Exemplo: <strong>O Problema de Minimização de Função</strong></h4>
<pre><code class="language-python">import math
import random

def objective_function(x):
    return x**2 + 10*math.sin(x)  # Função objetivo: minimizar f(x)

def simulated_annealing(start, temperature, cooling_rate):
    current_solution = start
    current_cost = objective_function(current_solution)

    while temperature &gt; 1:
        new_solution = current_solution + random.uniform(-1, 1)
        new_cost = objective_function(new_solution)

        # Aceita a nova solução com base na temperatura
        if new_cost &lt; current_cost or random.random() &lt; math.exp((current_cost - new_cost) / temperature):
            current_solution = new_solution
            current_cost = new_cost

        temperature *= cooling_rate  # Diminui a temperatura

    return current_solution, current_cost

# Exemplo de uso
start = 10
temperature = 1000
cooling_rate = 0.995
solution, cost = simulated_annealing(start, temperature, cooling_rate)
print(f&quot;Solução final: {solution

}, Custo: {cost}&quot;)
</code></pre>
<p>Neste exemplo, é usado <strong>Simulated Annealing</strong> para minimizar uma função matemática. O algoritmo explora novas soluções e aceita soluções piores com uma probabilidade que diminui com o tempo (temperatura), ajudando a escapar de mínimos locais.</p>
<hr />
<h2 id="algoritmos-geneticos-algoritmos-evolutivos">Algoritmos Genéticos (Algoritmos Evolutivos)</h2>
<p>Os Algoritmos Genéticos são técnicas de otimização inspiradas na evolução natural. Eles trabalham com uma população de indivíduos, onde cada indivíduo representa uma solução possível. Os indivíduos mais aptos, avaliados por uma função de fitness, reproduzem-se através de recombinação e mutação para formar a próxima geração. Esse processo se repete até alcançar uma solução satisfatória.</p>
<pre><code class="language-python">import random

def fitness(individual):
    return sum(individual)

def mutate(individual):
    idx = random.randint(0, len(individual)-1)
    individual[idx] = 1 - individual[idx]
    return individual

def crossover(parent1, parent2):
    point = random.randint(1, len(parent1)-1)
    return parent1[:point] + parent2[point:]

# Inicialização
population = [[random.randint(0,1) for _ in range(6)] for _ in range(4)]

# Evolução
for generation in range(5):
    population = sorted(population, key=fitness, reverse=True)
    print(f'Geração {generation}: {population}')
    next_gen = population[:2]
    while len(next_gen) &lt; 4:
        parent1, parent2 = random.sample(next_gen, 2)
        child = crossover(parent1, parent2)
        child = mutate(child)
        next_gen.append(child)
    population = next_gen
</code></pre>
<p><strong>Referências</strong></p>
<ul>
<li>Russell, S., &amp; Norvig, P. (2010). Artificial Intelligence: A Modern Approach (3ª ed.). Prentice Hall.</li>
<li>Ghallab, M., Nau, D., &amp; Traverso, P. (2004). Automated Planning: Theory and Practice. Morgan Kaufmann.</li>
<li>Nilsson, N.J. (1982). Principles of Artificial Intelligence. Tioga Publishing Co.</li>
<li>Holland, J. H. (1975). Adaptation in Natural and Artificial Systems.</li>
<li>Goldberg, D. E. (1989). Genetic Algorithms in Search, Optimization, and Machine Learning.</li>
<li>Mitchell, M. (1998). An Introduction to Genetic Algorithms.</li>
</ul>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var labels=set.querySelector(".tabbed-labels");for(var tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": ["navigation.tabs", "navigation.sections", "toc.integrate", "navigation.top", "search.suggest", "search.highlight", "content.tabs.link", "content.code.annotation", "content.code.copy"], "search": "assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.83f73b43.min.js"></script>
      
    
  </body>
</html>